#ifndef MINISQL_EXECUTE_ENGINE_H
#define MINISQL_EXECUTE_ENGINE_H

#include <string>
#include <unordered_map>
#include "common/dberr.h"
#include "common/instance.h"
#include "transaction/transaction.h"

#include "parser/syntax_tree_printer.h"
#include "utils/tree_file_mgr.h"

extern "C" {
int yyparse(void);
#include "parser/minisql_lex.h"
#include "parser/parser.h"
}

/**
 * ExecuteContext stores all the context necessary to run in the execute engine
 * This struct is implemented by student self for necessary.
 *
 * eg: transaction info, execute result...
 */
struct ExecuteContext {
  bool flag_quit_{false};
  Transaction *txn_{nullptr};

  string output_{""};//out put information
};

/**
 * ExecuteEngine
 */
class ExecuteEngine {
public:
 ExecuteEngine(std::string db_meta_file_name);

 ~ExecuteEngine() {
   for (auto it : dbs_) {
     it.second->bpm_->FlushAll();
     delete it.second;
   }
   delete heap_;
  }

  /**
   * executor interface
   */
  dberr_t Execute(pSyntaxNode ast, ExecuteContext *context);

private:
  dberr_t ExecuteCreateDatabase(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteDropDatabase(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteShowDatabases(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteUseDatabase(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteShowTables(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteCreateTable(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteDropTable(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteShowIndexes(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteCreateIndex(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteDropIndex(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteSelect(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteInsert(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteDelete(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteUpdate(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteTrxBegin(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteTrxCommit(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteTrxRollback(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteExecfile(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteQuit(pSyntaxNode ast, ExecuteContext *context);

  //my member functions
  dberr_t SelectTuples(const pSyntaxNode ast, ExecuteContext *context,TableInfo* tinfo, vector<IndexInfo*> iinfos, vector<Row>* row);//select the rows according to the condition node
  
  bool CompareSuccess(Field* f, pSyntaxNode p_comp, pSyntaxNode p_val, ExecuteContext *context);

  bool AddField(TypeId tid, char* val, vector<Field>& fields, ExecuteContext *context);//generate field according to input string, add it into fields

  bool RowSatisfyCondition(const Row &row, pSyntaxNode cond_root_ast, TableInfo *tinfo, ExecuteContext *context);//judge if a row satisfy the condition generated by the tree

 private:
  //if this values is true, then not allowed to build index on non-unique key (single field without unique declaration, multiple key)
  static bool index_constraint;

  std::unordered_map<std::string, DBStorageEngine *> dbs_; /** all opened databases */
  std::string current_db_;                                 /** current database */

  std::string engine_meta_file_name_;
  std::fstream engine_meta_io_;  // get meta message about existed databases(their name)
  MemHeap * heap_;
};

#endif //MINISQL_EXECUTE_ENGINE_H
