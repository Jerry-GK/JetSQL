- 你负责了哪些部分？
  数据的序列化与反序列化、buffer pool的设计、记录表页结构的设计、执行器的设计。

- 数据库文件的磁盘格式是怎样的？
- buffer pool有什么作用？
- buffer pool对页的unpin是什么含义和作用？
- 堆表管理表页是什么意思？
- 执行器如何执行SQL语句？执行计划是什么？
- 如何实现LRU替换策略？


- 日志的格式是怎样的？
- 怎样用日志实现崩溃恢复，undo、redo的流程是怎样的？
- 怎样用日志维护事务的原子性？
- 怎样实现物理层面的多线程并发？
  给page进行latch和unlatch操作。
  对共享的数据结构，比如disk、bp、log的manager以及全局变量加recursive mutex

- 做过哪些优化？
  1. 最小堆代替链表管理表页。
  2. LRU算法的优化。
  3. B+树的keysize实现动态大小
  4. 自己实现的高效内存池 
   
- 项目遇到过哪些困难，怎样克服？
  1. 页泄露，原因是pin和unpin/delete不一一匹配
     解决：手动匹配保证（难点）
  2. 性能瓶颈：链式表+LRU在连续插入时性能极差
     解决：用堆表
  3. 性能瓶颈：内存分配耗时。
     解决：修改STL为自己写的数据结构管理memheap
  4. 性能瓶颈：row的反序列化占据了绝大部分时间
     解决：row的反序列化大多数出现在索引的比较上，比较在所难免，直接比较序列化前的结果反而更慢，所以难以解决。
  5. 粒度问题：以页为粒度进行并发控制和日志恢复，性能和开销不好。但不同页没有统一结构，细粒度下不好统一管理。
     无法解决
  6. disk manager对于disk meta和bitmap页单独维护page cache管理，与buffer pool独立，日志无法管理。（日志的添加和利用都是跟bpMgr对接）
     另外disk manager的缓存访问也没有进行页的物理并发控制。
   - 思路1: logMgr与diskMgr直接对接（不可行，log需要记录没写入disk的信息）
   - 思路2: log只跟diskMgr的元信息管理部分对接，也就是page cache处 # 需要对log分类，undo/redo时需要用diskMgr的接口（耦合性增大，不仅diskMgr需要生成记录，它还需要根据记录进行恢复，非常麻烦）
   - 思路3：bpMgr可以直接管理磁盘的meta和bitmap page，将磁盘管理信息纳入bp管理，diskMgr只负责页的读写。对外bpMgr仍只提供逻辑页访问接口。
   - 思路4：强制diskmeta和bitmap页直接写磁盘（影响性能，仍然无法rollback，不可行）
     解决：其实根本不需要解决，因为更新数据页会顺带更新元页。只需要在刚创建数据库时将元页先flush一遍即可。
  7. 日志NEW类型的记录，redo时重新分配时，或DELETE记录，undo重新分配时，新页无法保证pid与旧页一致，后面的日志记录又不方便同步修改pid号。 即使可以做到修改日志页号，也不可能同时修改disk中全部跟逻辑页号相关的地方。
     无法解决！！！（最大的问题）。逻辑页号由磁盘位置决定，难以保证重新newpage时页号相同。
  8. 迭代器的生命周期问题
  9.  多线程：共享buffer pool、diskMgr、logMgr，带来很多奇奇怪怪的并发问题。
     暂未解决