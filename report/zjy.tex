\documentclass[12pt, a4paper]{article}
\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\usepackage{fontspec}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{amsmath}
\usepackage{caption}    
\usepackage{diagbox}
\usepackage{multirow}
\usepackage{pgfplots}
\usepackage{tabularx}
\usepackage{xeCJK}

% \setCJKmainfont{Arial}

% Geometry & color settings

\geometry{a4paper,left=3cm,right=3cm,bottom = 4cm,top = 4cm}
\definecolor{green}{rgb}{0,0.6,0}
\definecolor{orange}{rgb}{1,0.4,0.1}
\definecolor{blue}{rgb}{0,0.4,0.9} 
\definecolor{grass}{rgb}{0.6,0.9,0.2}

% Listing setrings

\lstdefinestyle{customc}{
    language        =   C,
    basicstyle      =   \small\ttfamily,
    numberstyle     =   \small\ttfamily,
    keywordstyle    =   \color{blue},
    stringstyle     =   \color{orange},
    commentstyle    =   \color{green}\ttfamily,
    breaklines      =   true,
    basewidth       =   0.6em,
    columns         =   fixed,
    numbers         =   left,
    basewidth       =   0.5em,
}

\lstset{
    basicstyle          =   \small\ttfamily,
    keywordstyle        =   \small\ttfamily, 
    commentstyle        =   \small\ttfamily,
    stringstyle         =   \small\ttfamily,
    flexiblecolumns,              
    numbers             =   none, 
    showspaces          =   false, 
    numberstyle         =   \small\ttfamily,  
    showstringspaces    =   false,
    breaklines          =   true,
    captionpos          =   lt,  
    frame               =   lrtb,  
    tabsize             =   4,
}

% Macros
\def\c#1{\texttt{#1}}
\def\b#1{\textbf{#1}}
\def\bc#1{\b{\c{#1}}}
\def\s#1{\section{#1}}
\def\ss#1{\subsection{#1}}
\def\sss#1{\subsubsection{#1}}
\def\sz#1#2{{\fontsize{#1}{#1}{#2}}}
\def\pid{page\_id\_t\ }
\def\fid{frame\_id\_t\ }
\def\p{\par}
\def\gx#1{\begin{center}\includegraphics[width=1.2\linewidth]{#1}\end{center}}
\def\g#1{\begin{center}\includegraphics[width=1.0\linewidth]{#1}\end{center}}
\def\gl#1{\begin{center}\includegraphics[width=0.85\linewidth]{#1}\end{center}}
\def\gm#1{\begin{center}\includegraphics[width=0.7\linewidth]{#1}\end{center}}
\def\gh#1{\begin{center}\includegraphics[width=0.6\linewidth]{#1}\end{center}}
\def\gs#1{\begin{center}\includegraphics[width=0.5\linewidth]{#1}\end{center}}
\def\gp#1{\begin{center}\includegraphics[width=0.5\linewidth]{#1}\end{center}}
\def\gt#1{\begin{center}\includegraphics[width=0.3\linewidth]{#1}\end{center}}
\def\q#1{\begin{quote}\b{#1}\end{quote}}

% Meta informations

\titleformat*{\section}{\LARGE\bfseries}
\titleformat*{\subsection}{\Large\bfseries}
\titleformat*{\subsubsection}{\large\bfseries}
\titleformat*{\paragraph}{\large\bfseries}
\titleformat*{\subparagraph}{\large\bfseries}

\setlength{\parindent}{2em}
\author{\sz{20}{\b{张峻瑜}}}
\title{\sz{30}{\b{MiniSQL个人详细报告}\vspace{+4ex}}}
\pagestyle{headings}
\date{\sz{20}{\b{时间：2022年6月4日}}}




\begin{document}

\maketitle
\newpage
\tableofcontents
\s{个人分工说明}
\p 本人在本项目中主要负责如下几个部分：DiskManager的实现，BufferPoolManager的实现以及LRU Replacer的优化、Clock replacer的实现、Index的实现并重构了Index模块，抛弃了原有模板的设计、CatalogManager的实现、内存管理方式上的优化以及ManagedHeap的实现。
\s{我完成的工作}

\ss{DiskManager模块}
本项目中，每个数据库的数据各自存储在单一文件之中，文件名为\{数据库名\}.db。该文件被划分为若干个页\c{(page)},每页大小为4096字节。每个页被物理页号\c{(physical\_page\_id)}唯一标识,同时其中的用户页具有供上层模块标识用的逻辑页号\c{(logical\_page\_id)}。页的分配、释放、读取与写入由DiskManager模块统一管理。
\begin{itemize}
	\item 用户页 : 上层模块通过DiskManager申请的页。
 \item 系统页 : 除过用户页之外的页。这些页被DiskManager用于存储关于磁盘、页管理的原信息。
 \item 物理页号：DiskManager从磁盘写入/读出页时使用的页号，物理页号与页一一对应。
 \item 逻辑页号：为了隐藏DiskManager的实现细节，系统页对上层模块不可见，只有用户页能被上层模块访问。每个用户页被逻辑页号唯一标识。在用户页中，逻辑页号从0开始连续增长。
\end{itemize}
\p .db文件的文件布局如下：
\g{file_layout.pdf}
\p 为了加速页的分配与删除，本项目不仅仅对用户页采用了缓存，也对系统页采用了缓存。系统页的缓存由DiskManager单独管理，管理的函数为：
\begin{itemize}
	\item \c{ReadPhysicalMetaPage(page\_id\_t physical\_page\_id)}\begin{enumerate}
		\item 从buffer中寻找该页
  \item 若找到，则直接从内存中读取
  \item 若未找到，则从磁盘中读取，并通过\c{replacer\_}替换掉buffer中的某页。
  \item 若被替换的页为dirty，则把该页写入磁盘
	\end{enumerate}
 \item \c{WritePhysicalMetaPage(page\_id\_t physical\_page\_id)}\begin{enumerate}
	 \item 从buffer中寻找该页
  \item 若未找到，将该页存入buffer，写入数据，并标记为dirty
  \item 若找到，直接写入数据，并标记为dirty
 \end{enumerate}
\end{itemize}
\p \c{DiskManager}模块的接口以及实现如下：
\begin{itemize}
	\item \c{void\ ReadPage(page\_id\_t logical\_page\_id, char *page\_data)} : 从文件中读取\c{logical\_page\_id}标识的用户页，并把页数据写入 page\_data指向的内存中。\begin{enumerate}
  \item 调用\c{IsPageFree()}，若该页未被分配，抛出错误。
  \item 若该页未被分配，调用\c{ReadPhysicalPage()}读取数据。\c{ReadPhysicalPage}的实现如下：\begin{enumerate}
	  \item 调用\c{MapPageId()},根据逻辑页号计算出\c{extent\_id}对应的位图页与物理页号
   \item 调用\c{ReadPhysicalMetaPage()}，读取位图页
   \item 若位图页中该页对应的\c{bit}为0，抛出异常
   \item 否则，将该页的数据读入内存
  \end{enumerate}
	\end{enumerate}
 \item \c{void WritePage(page\_id\_t logical\_page\_id, const char *page\_data)} : 将\c{page\_data}指向的4096字节写入logical\_page\_id所标识的用户页对应的文件块中。\begin{enumerate}
 \item 调用\c{IsPageFree()}，若该页未被分配，抛出错误。
   \item 调用\c{MapPageId()},根据logical\_page\_id计算physical\_page\_id。
   \item 调用\c{ReadPhysicalPage()}，将数据读入内存。
 \end{enumerate}
 \item \c{page\_id\_t AllocatePage()} : 申请分配一个用户页，返回新分配用户页的逻辑页号。\begin{enumerate}
   \item 根据\c{next\_extent\_id\_}，找到对应extent的位图页。若大于\c{GetMaxExtentNum()}，抛出异常。
   \item 从位图页中获取\c{next\_free\_page}，若大于\c{GetMaxSupportedSize()}，抛出异常。
   \item 调用\c{BitmapPage::AllocatePage}，分配一个页，并保存分配的页号。
   \item 更新\c{BitmapPage::next\_free\_page\_}。
   \item 更新\c{next\_unfull\_extent\_}。
   \item 返回分配的页号。
 \end{enumerate}
 \item \c{void DeAllocatePage(page\_id\_t logical\_page\_id)} : 释放被logical\_page\_id所标识的用户页。\begin{enumerate}
   \item 调用\c{IsPageFree}，若未被分配，抛出错误。
   \item 调用\c{ReadPhysicalMetaPage}，读入位图页。
   \item 调用\c{BitmapPage::DeAllocatePage}，释放页，若失败则抛出错误。
   \item 更新\c{BitmapPage::next\_free\_page\_}。
   \item 更新\c{next\_unfull\_extent\_}。
 \end{enumerate}
 \item \c{bool IsPageFree(page\_id\_t logical\_page\_id)}:查询被logical\_page\_id所标识的用户页是否已经被分配。\begin{enumerate}
   \item 调用\c{FetchPhyscicalMetaPage}，获取对应的位图页。
   \item 根据位图页中对应的位，返回分配情况。
 \end{enumerate}
 \item \c{void Close()} ： 关闭DiskManager,保存相关信息，释放文件句柄。\begin{enumerate}
   \item 将全部buffer中的dirty页写入磁盘。
   \item 将\c{DiskMetaPage}写入磁盘。
   \item 释放buffer的内存。
 \end{enumerate}
\end{itemize}
\p 该模块的依赖关系图如下：
\g{./dots/DiskManager.pdf}
\ss{BufferPoolManager模块}
\gm{buffer_pool_manager.pdf}
为了提升从磁盘读/写页的速度， \c{BufferPoolManager}对所有用户页进行了缓存处理，这大大加快了上层模块获取/写入页数据的速度。
\p 该模块的依赖关系图如下：
\g{./dots/BufferPoolManager.pdf}
\p 该模块的接口及实现如下：
\begin{itemize}
  \item \c{Page * FetchPage(\pid LogicalPageId)}：获取LogicalPageId标识的用户页对应的Page对象。\begin{enumerate}
    \item 检查该页是否在缓存中。
    \item 若不在，从free\_list中获取或调用replacer获取要替代的缓存页，并把目标页读入该缓存页。
    \item 目标页引用计数加一。
    \item 返回目标页对应的Page对象。
  \end{enumerate}
  \item  \c{bool UnPinPage(\pid LogicalPageId,bool dirty)}：引用计数减一。
  \item \c{\pid NewPage(\pid \& pageId)}：申请分配一个用户页。\begin{enumerate}
    \item 调用\c{DiskManager::AllocatePage}，申请分配一个新的用户页。
    \item 将该页加入缓存，引用计数加一。
  \end{enumerate}
  \item \c{bool DeletePage(\pid pageId)}：删除一个用户页。\begin{enumerate}
    \item 检查该页是否在缓存中。
    \item 若在，从缓存和replacer中移除该页，将对应的frame加入free\_list
    \item 调用\c{DiskManager::DeAllocatePage}，释放该页。
  \end{enumerate}
  \item \c{FlushPage(\pid pageId)} : 手动将该页写入磁盘。
  \item \c{FlushAll} : 将全部为dirty的页写出磁盘。
  \item \c{IsPageFree} : 查询该页是否已被分配。 
\end{itemize}
\ss{IndexManager模块}
\gm{b_plus_tree_index.pdf}
\p IndexManager负责管理索引项的添加、删除与访问。由于索引本身特殊的数据结构，给定某个键，我们能够快速的从索引中获取该键对应记录的RowId，从而快速从堆表中取得该行记录。本项目实现了在\b{任意长度}键上建立几乎\b{零额外空间消耗}（也就是，除了存储键本身的值与RowId所需的空间之外，几乎没有额外的空间消耗）的B+树索引。在一个表的一个索引之中，包含了若干个索引项。每个索引项由两部分构成：IndexKey 与 RowId。IndexKey存储了键值，RowId存储了该索引项对应记录在堆表中的位置。本模块的功能就是实现建立B+树索引、删除、添加、访问索引项的功能。
\g{b_plus_tree.pdf}
\p 一颗B+树由若干个叶子节点(\c{BPlusTreeLeafPage})与内部节点(\c{BPlusTree InternalPage})构成。内部节点按照增序存储了若干个子树的最小键值，以及子树的根节点页号。索引项以增序存储在叶子节点之中。每个内部节点或者叶子节点都单独占用一整个用户页。对于不同的索引，其IndexKey所占空间不同，因此每个内部节点与叶子节点所能存储的最大项数也不同，且在程序运行期间动态计算决定。以下是IndexKey、BPlusTreePage、BPlusTreeLeafPage与BPlusTreeInternalPage的内存布局。
\g{b_plus_tree_pages.pdf}
BPlusTreePage、BPlusTreeLeafPage与BPlusTreeInternalPage的继承关系如下：
\g{b_plus_tree_page_inherit.pdf}
\p 值得注意的是，本模块摒弃了原框架中的模板设计，而是采用了单一的类来实现BPlusTreeIndex，该实现方法有诸多好处，详见"设计亮点与Bonus"章节。
\p 本项目未采用GenericKey以及GenericComparator，而是使用自己实现的IndexKeyComparator来进行IndexKey之间的比较。原理与GenericComparator相同，但在内存管理方式上略有区别，详见"设计亮点与Bonus"章节。
\p 本模块提供的接口以及实现如下：
\begin{itemize}
  \item \c{BPlusTreeIndex::InsertEntry(const Row \&key,RowId rowid)}：插入一个索引项。\begin{enumerate}
    \item 将row序列化为Indexkey.
    \item 调用\c{BPlusTree::Insert}函数，尝试插入该key。
    \item 若插入失败，则代表已有重复键值，返回False.
    \item 否则，返回true.
    \item \c{BPlusTree::Insert}函数实现如下：\begin{enumerate}
      \item 调用\c{BPlusTree::InternalInsert()}，插入键值，并获取可能的“分裂页”。分裂页指的是，插入子节点导致节点分裂而产生的新页。
      \item 若有重复，返回false。否则：
      \item 若有分裂页，创建新的树根，并将两个子树连接到树根上。
      \item 返回true.
      \item \c{BPlusTree::InternalInsert}函数实现如下：\begin{enumerate}
        \item 若该页为叶子节点，执行2。否则执行6。
        \item 若有重复，则返回：重复。
        \item 将IndexKey与RowId组合成BLeafEntry，并二分查找，插入该项。
        \item 若页已满，则申请新页，并对半分配两页所含的索引键值。
        \item 返回：节点中第一个键值、新分配的页、无重复。
        \item 二分查找，找到要插入索引项应当处于的子节点x，调用\c{InternalInsert(x)}。
        \item 若有重复，则返回：重复。
        \item 若无新创建的页，则返回：节点中第一个键值、无重复。
        \item 否则，将新页插入该节点。
        \item 若页已满，则申请新页，并对半分配两页所含的索引键值。
        \item 返回：节点中第一个键值、新分配的页、无重复。
      \end{enumerate}
    \end{enumerate}
  \end{enumerate}
  \item \c{BPlusTreeIndex::RemoveEntry(const Row \&key)}：删除一个索引项。\begin{enumerate}
  \item 将row序列化为Indexkey。
  \item 调用\c{BPlusTree::Remove}。
  \item \c{BPlusTree::Remove}的实现如下：
  \item \begin{enumerate}
    \item 调用\c{BPlusTree::InternalRemove()}，移除索引项。
    \item 若返回未找到，则返回false。
    \item 若某个子节点的子节点数变为0，则删除该子节点。
    \item 若仅有一个子节点，则删除根节点，并把子节点作为新的根节点。
    \item \c{BPlusTree::InternalRemove()}的实现如下：\begin{enumerate}
      \item 若该节点为叶子节点，执行2。否则，执行4。
      \item 二分查找，尝试删除。
      \item 若未找到，返回错误，否则，返回该节点的size与第一项的键值。
      \item 该节点为内部节点，二分查找找到要下一步搜索子节点。
      \item 调用\c{BPlusTree::InternalRemove()}。
      \item 若未找到，返回错误。
      \item 若子节点的size小于\c{GetMinSize()}，尝试将子节点与其伙伴节点合并，或者从其伙伴节点中调换一个索引项到子节点中。
      \item 返回该节点的size与第一项的键值。
    \end{enumerate}
  \end{enumerate}
  \end{enumerate}
  \item \c{BPlusTreeIndex::Scankey}：读取一个索引项。\begin{enumerate}
    \item 沿着B+树自顶向下递归查找。在每个节点内部，采用二分查找算法。
  \end{enumerate}
  \item \c{BPlusTreeIndex::GetBeginIterator}：获取首迭代器。该迭代器的键值从最小或指定索引项开始递增，到尾迭代器结束。
  \begin{enumerate}
    \item 二分查找。
  \end{enumerate}
  \item \c{BPlusTreeIndex::FindLastSmallerOrEqual(const Row \& key)}：获取最后一个小于等于key的索引项的迭代器。\begin{enumerate}
    \item 二分查找。
  \end{enumerate}
  \item \c{BPlusTreeIndex::GetEndIterator}：获取尾迭代器。
\end{itemize}
\p 不同于TableHeap的迭代器，B+树的迭代器本身并不存储任何实际数据。这是由于B+树迭代器解引用之后所得的数据与实际存储在内存中的数据一致，因此无需分配额外的空间。BPlusTreeIterator解引用之后，返回的就是实际存储在叶子节点之中的索引项。迭代器成员如下：
\begin{itemize}
  \item BPlusTree* tree : Iterator所在的B+树。
  \item BPlusTreeLeafNode * ：Iterator所在的叶子节点。在Iterator创建直到End或者析构期间，该节点对应的page始终被pin.
  \item Schema * ：用于BPlusTreeIteraotr::IsNUll()，判断该迭代器对应的索引项键值是否为空。
\end{itemize}
\p 类关系图如下：
\g{dots/b_plus_tree_index.pdf}
\g{dots/index_iterator.pdf}
\ss{CatalogManager模块}
\p CatalogManager管理了所有表、索引以及整个数据库的元信息，并把这些元信息与对应的数据结构关联起来，并为Executor提供查询、获取元信息与数据结构的接口。
\p 具体的做法如下：ExecuteEngine可以经由CatalogManager凭借TableName , IndexName 获取表与索引的信息，也就是：IndexInfo 与 TableInfo。
\p IndexInfo中包含了Index的元信息：IndexMetaData，并且IndexMetaData直接存储在磁盘中。同理，TableInfo包含了Table的元信息：TableMetaData。
除此之外，IndexInfo也包含了指向BPlusTreeIndex的指针，TableInfo包含了指向TableHeap的指针。Executor可以通过这些来判断一个索引或者表是否存在、列与索引的定义、以及操纵索引与表中实际存储的数据。
\p 此外，CatalogManager还管理了整个数据库中哪些表、哪些索引，以及索引的根节点信息。所有索引的根节点信息存储在一个单独的名为\c{INDEX\_ROOTS\_PAGE}的用户页中。
\p 以上介绍的相互关系可以用下图表示。
\g{catalog_manager.pdf}
\p CatalogMetaData 、IndexMetaData、TableMetaData的结构如下图所示：
\g{catalog_metadata.pdf}
\p TableInfo 、 IndexInfo的数据成员如下：
\begin{lstlisting}[style = customc]

class IndexInfo {
 private:
  IndexMetadata *index_meta_;
  Index *index_;
  TableInfo *table_info_;
  IndexSchema *key_schema_;
  MemHeap *heap_;
};

class TableInfo {
 private:
  TableMetadata *table_meta_;
  TableHeap *table_heap_;
  MemHeap *heap_; /** store all objects allocated in table_meta and table heap */
};

\end{lstlisting}
\begin{itemize}
  \item CreateTable(const std::string \&table\_name, TableSchema *schema, Transaction *txn, TableInfo *\&table\_info) ：创建表。\begin{enumerate}
    \item 检查表是否重名，若重名，返回错误。
    \item 为表分配root page 与TableMetaPage
    \item 创建TableMetaData对象
    \item 创建TableInfo对象
    \item 写入对应的页中
    \item 更新CatalogMeta与CatalogManager
  \end{enumerate}
  \item GetTable(const std::string \&table\_name, TableInfo *\&table\_info);\begin{enumerate}
    \item 检查表是否存在，若不存在，返回错误
    \item 从TableInfo 的map中取出TableInfo *
  \end{enumerate}
  \item GetTables(std::vector<TableInfo *> \&tables) const;\begin{enumerate}
    \item 遍历TableInfo的map，逐个存入数组。
  \end{enumerate}
  \item \c{CreateIndex(const std::string \&table\_name, const std::string \&index\_name,
  const std::vector<std::string> \&index\_keys, Transaction *txn, IndexInfo *\&index\_info);}\begin{enumerate}
    \item 检查表是否存在，若不存在，返回错误。
    \item 检查索引是否重名，若重名，返回错误。
    \item 检查列是否在表中存在，若不存在，返回错误
    \item 为索引分配index root page 与index meta page
    \item 创建IndexMetadata对象
    \item 创建IndexInfo对象
    \item 更新CatalogMeta与CatalogManager
    \item 返回IndexInfo *对象的指针
  \end{enumerate}
  \item \c{GetIndex(const std::string \&table\_name, const std::string \&index\_name, IndexInfo *\&index\_info) const;
  \item GetTableIndexes(const std::string \&table\_name, std::vector<IndexInfo *> \&indexes) const;}\begin{enumerate}
    \item 查询map<std::string, map<std::string, index\_id\_t>>，返回对应的全部IndexId
  \end{enumerate}
  \item \c{DropTable(const std::string \&table\_name);}\begin{enumerate}
    \item 检查表是否存在，若不存在，返回错误。
    \item 调用DropIndex，删除表上的全部索引
    \item 调用TableHeap->FreeHeap，删除堆表中的全部数据。
    \item 释放TableMetaPage。
    \item 析构TableHeap、TableMetaData、TableInfo对象。
    \item 更新CatalogManager与CatalogMeta
  \end{enumerate}
  \item \c{DropIndex(const std::string \&table\_name, const std::string \&index\_name)};\begin{enumerate}
    \item 检查索引是否存在，若不存在，返回错误。
    \item 调用Index->Destroy，删除索引中的全部数据。
    \item 释放IndexMetaPage。
    \item 析构BplusTreeIndex,IndexMetaData,IndexInfo对象。
    \item 更新IndexRootsPage。
    \item 更新CatalogManager与CatalogMeta。
  \end{enumerate}
\end{itemize}
\p 类关系图如下：
\g{dots/catalog_manager.pdf}

\ss{Replacer的优化与多种Replacer的实现}
\sss{LRUReplacer的优化}
在普遍的实现中，LRUReplacer的算法如下：
\begin{itemize}
  \item 对于每个frame,维护lastUsedTime,代表该frame上一次被访问的时间。
  \item 维护一个list,包含了可以被替换的fid
  \item \c{UnPin(\fid fid)} :\begin{enumerate}
    \item 将所有在list中的fid对应的lastUsedTime加1
    \item 将fid对应的加入list，并设置lastUsedTime为0
    \item 时间复杂度：$O(N)$
  \end{enumerate} 
  \item \c{Pin(\fid fid)} : \begin{enumerate}
    \item 将fid从list中移除。
    \item 时间复杂度： $O(1)$
  \end{enumerate}
  \item \c{Victim()} : \begin{enumerate}
    \item 遍历所有list中的fid
    \item 找到lastUsedTime最大的fid
    \item 从list中移除fid，并返回fid
    \item 时间复杂度：$O(N)$
  \end{enumerate}
\end{itemize}
\p 由于\c{Unpin}和\c{Pin}函数的使用极为频繁，因此\c{Unpin}的复杂度为$O(N)$是不可接受的。因此，本项目放弃原框架中\c{unordered\_set}实现，改用数组实现，并提供了以下等价的优化算法：
\begin{itemize}
  \item 对于每个frame,维护lastUsedTime,代表该frame上一次被访问的时间。
  \item 维护一个list,包含了可以被替换的fid 
  \item 维护min\_time,表示所有lastUsedTime中的最小值。
  \item \c{UnPin(\fid fid)} :\begin{enumerate}
    \item 将fid对应的加入list，并设置lastUsedTime为min\_time - 1
    \item 若发生溢出，则把所有的lastUsedTime加1。
    \item 均摊时间复杂度：$O(1)$
  \end{enumerate} 
  \item \c{Pin}与\c{Unpin}原理与之前的大致相同。
\end{itemize}
\sss{ClockRepalcer的实现}
\p Clock Replacer, 顾名思义，像钟表一样的replacer。Clock replacer 维护一个环形数组，其中的Clock pointer在每次victim()被调用时，循环地向后寻找第一个未被访问并且present的项，并返回该项。
\p 简单原理图如下，ref表示是否已被访问。每次clock pointer扫描到一项时，就将ref设置为false。
\g{clock_replacer.pdf}
\p 后续的测试标明,clock replacer的性能与lru replacer（优化后）相当，都远大于优化之前的lru replacer,这是由于clock replacer的unpin 、pin操作都是$O(1)$的。
\p 具体实现如下：
\begin{itemize}
  \item \c{Victim} : \begin{enumerate}
    \item 从clock pointer向后遍历所有项，若达到结尾则返回开头。
    \item 寻找第一个ref为false且present的项，同时把经过的项的ref设置为false。
  \end{enumerate}
  \item \c{Unpin} : \begin{enumerate}
    \item 将该项对应的ref设为true
    \item 将该项对应的present设为true
  \end{enumerate}
  \item \c{Pin} :\begin{enumerate}
    \item 将该项对应的present设为false
  \end{enumerate}
\end{itemize}
\ss{Index的重构和去模板化}
\p 在原项目框架中，\c{BPlusTreeIndex、BPlusTreeIndex}为模板类，接受三个模板参数\c{KeyType} , \c{ValueType} , \c{KeyComparator}，功能分别为：
\begin{itemize}
  \item \c{KeyType} ： 键的类型
  \item \c{ValueType} : 值的类型
  \item \c{KeyComparator} : 用于比较键的类
\end{itemize}
\p 这种设计存在多种缺点。其中部分缺点是：
\begin{enumerate}
  \item 浪费空间。\c{KeyType}只支持特定长度的key（在原框架中，这些长度分别是4,8,16,32,64）。这意味着对于长度略大于2的次幂的那些key，将会有接近一半的存储空间被浪费。
  \item 灵活性差。key具体需要多少长度，在运行期间是未知的，这就要求我们动态地根据key的长度对模板类进行实例化，破坏了封装性与代码的整洁。其次，模板类不可能实例化所有可能的长度，因此能够支持的key长度存在上限。
  \item 代码膨胀。如果要对Keysize进行更加细粒度的划分，将不可避免的实例化大量的模板类，这将造成巨幅的代码膨胀。
\end{enumerate}
\p 当然，这种设计也存在一些优点，比如代码编写比较容易。
\p 因此，本项目放弃了模板的设计，改用单一的\c{BPlusTree , BPlusTreeIndex , BPlusTreePage}类实现B+树的操作，提高了灵活性，且节省了空间。具体做法是：
\begin{enumerate}
  \item 将keysize作为成员保存在\c{BPlusTreePage}中。该成员在\c{BPlusTreePage}被创建时初始化。
  \item 将max\_size作为成员保存在\c{BPlusPage}中，代表该Page最多能保存的Entry数量。该成员在\c{BPlusTreePage}被创建时初始化。
  \item 将\c{BPlusTreeLeafPage}的\c{ValueType}固定为\c{RowId}
  \item 将\c{BPlusTreeInternalPage}的\c{ValueType}固定为\c{\pid}
  \item 将\c{KeyType}固定为\c{IndexKey}，\c{IndexKey}的成员如下：\begin{lstlisting}[style=customc]
struct IndexKey{
  uint8_t keysize;
  char value[0]; // 柔性数组
}
  \end{lstlisting}
  \item GenericComparator同时也去掉模板参数，变为IndexKeyComparator。由于IndexKey中包含了keysize成员，key的长度已知，因此可以进行比较。
\end{enumerate}
\p \bc{BPlusPage } 成员如下 :\begin{lstlisting}[style=customc]
class BPlusTreePage{
  // ... 
  private:
   IndexPageType page_type_;
   lsn_t lsn_;
   int key_size_; //键长度
   int size_; //当前键数
   int max_size_; //最大键数
   page_id_t parent_page_id_;
   page_id_t page_id_;
};

\end{lstlisting}
相关内存布局如下：
\g {b_plus_tree_pages.pdf}
\ss{内存管理机制的多种优化}
\sss{内存管理机制的优化}
\p 基于原框架中MemHeap的思想，本项目进一步优化了对内存的管理。
\p 在本项目中，涉及到大量类对象的动态创建与销毁，内存管理是一个十分重要的方面。这是由于：
\begin{itemize}
  \item 如果对动态创建的对象的生命周期管理不当，很容易造成内存泄露，尤其是在处理万级别的数据量时，使得程序无法持续运行。
  \item 大量临时对象的创建与销毁，若采用原始的内存分配方式，将导致极大的性能开销。
  \item 原有的SimpleMemHeap性能不足。
\end{itemize}
\p 基于MemHeap的内存管理方式，我们提出以下两个概念：
\begin{itemize}
  \item “主对象”：成员包括MemHeap，在heap上分配或者销毁自身的成员，且负责MemHeap的创建与销毁。
  \item “从对象”：成员包括MemHeap，在heap上分配或者销毁自身以及自身的生源，但无权创建或者销毁Memheap的对象。
  \item 对于无需堆方式内存管理的对象，不在考虑范围之内。
\end{itemize}
\p 之所以有这样的划分，是由于memheap的创建与销毁具有一定的性能开销。若memheap也由临时对象维护，那么频繁的创建与删除memheap（比如原框架中row对象）将占用大量时间，且无法复用已分配的内存。因此，只有那些能够在内存中驻留较长时间的对象，才能对memheap进行管理。
\p 基于以上概念，我们做出以下划分：
\begin{itemize}
  \item 主对象：\c{ExecuteEngine},\c{\_\_\_Manager},\c{TableHeap},\c{IndexKeyComparator}
  \item 从对象：\c{Schema},\c{Column},\c{Row},\c{Field},\c{Type}
\end{itemize}
\p 这样一来，便形成了如下的内存管理关系图：
\g{mem_relation.pdf}
\p 最终，本项目实现了0内存泄露。（仅有的内存泄漏来自于googletest,此外，还修复了parser模块中部分内存泄露。）
\p \b{当然，每次在比较key 的时候都对Row进行deserialize，以及row对象的频繁创建与销毁，依然占据了除去文件读写以外80\%的时间。在一个数据库系统之中，是否应该对于同一个record创建如此多的临时拷贝，并且通过反序列化的方式来进行比较，我认为是一个值得思考的问题。}
\sss{高效内存池的实现}
\g{imgs/mem_heap.png}
\p 此外，本项目实现了一个高效快速的内存池：ManagedHeap。
\p MemHeap用于更有效地管理内存分配和回收，析构会自动释放分配的内存空间，尽量避免内存泄露的问题，也能减少频繁malloc对性能的影响。
\p MemHeap内部维护了已经分配空间的所有的指针集合，并在free时进行删除释放，析构时全部删除释放。在MiniSQL中主要为堆表、row、heap，catalog、 executor所需要生成的对象分配空间，其分配空间的操作（Allocate函数）在程序执行的过程在被调用的频率极高（其中大部分是row的heap为每个field分配空间），在实际性能测试（perf分析）的过程中发现其对性能的影响极大，占用了主要的时间（优化前，debug模式插入带索引的10万行约300秒）
\p \b{VecHeap}：在分析中我们发现SimpleHeap内部通过维护一个unordered\_set来存储指针，这种数据结构在查找时速度较快。但我们发现这样会导致插入的复杂度较高，而free往往是析构时一并执行的。相比于单个free操作，单个allocate的操作要频繁的多，所以我们将unordered\_set改成了vector，即VecHeap，发现速度提升了（从300秒加快至200秒左右）
\p \b{ListHeap}：但是VecHeap的性能仍不是很理想，其push\_back依然占据了程序执行的大部分时间（约60\%~80\%），后来我们发现，由于在MiniSQL中大部分Allocate的场景是row的MemHeap去维护它的每个field的空间，而field的数量通常不会很大（个位数，或几十个），在这种较少的数据量下，使用STL提供的vector或set来维护可能显得臃肿而没必要。因此我们手写了简单的链表用来存储指针，使得插入复杂度为O(1)，而删除则需要遍历。在这种轻量级的数据结构下，速度得到了大幅提升，debug模式下插入带索引的10万行的时间加快到了约34秒
\p \b{ManagedHeap：}
\q{设计思想}
\p 在数据库运行的过程中，会有大量临时的Row对象与Field对象不断被生成或者销毁。对于这些临时的对象，无需再重新调用operaotr new – delete 或者 malloc - free 进行内存的申请和释放，这些system call 本身的性能开销就比较大。只需要重复利用之前已经被申请过的内存即可。ManagedHeap中先前被分配的内存在被释放时，该内存块不再被返还给操作系统，而是被ManagedHeap标记为free，后续内存的分配可以直接复用这块内存，大大降低了内存申请与释放的开销。
\q{总体架构}
\g{managedHeap.pdf}
\p ManagedHeap由若干个Chunk组成，每个Chunk代表一块较大的内存。相邻Chunk的大小以2为倍数倍增。
在每个Chunk中，内存被线性地从前往后划分为若干个Block，每个Block的状态为已分配或空闲。
在每个Block中，首部和尾部各自维护了一个完全相同的BlockHeader，记录了该Block的分配信息，其中包括：
\begin{itemize}
  \item 该Block的大小
  \item 该Block是否已被分配
  \item 若该Block未被分配，记录上一个free Block 相对 chunk起始的偏移
  \item 若该Block未被分配，记录上一个free Block 相对 chunk起始的偏移
\end{itemize}
\p ChunkHeader数组维护了每一个Chunk的信息，其中包括：
\begin{itemize}
  \item Chunk起始地址
  \item Chunk大小，以字节计
  \item 该Chunk中第一个free block
\end{itemize}
\p 这样设计的优点在于，不仅能通过链表的结构快速的获取到空闲的块，还能根据某一个块的地址快速获取到相邻块的信息，从而完成块的分割或者合并。
\p ManagedHeap的分配与释放实现如下：
\begin{itemize}
  \item \c{Allocate(size)} : \begin{enumerate}
    \item 计算能够容纳size大小的第一个chunk。
    \item 从该chunk的第一个free block开始，沿着链表查找，若未找到则从下一个chunk中继续，直到找到满足大小的free block。
    \item 若该block的大小显著大于size，则对block进行分割，将新产生的空闲block加入free list中。
    \item 将该block从双向链表中删除，并对chunk的free pointer、链表中前后Block头中的指针进行更新。
  \end{enumerate}
  \item \c{Free(void * p)} ：\begin{enumerate}
    \item p1 = p - sizeof(BlockHeader)，计算得控制块的地址。
    \item 检查魔数，判断该块内存是否由本heap分配。若否，抛出错误。
    \item 将该chunk的free pointer设置为p1,并把该块标记为free。
    \item 将该块的相邻的也为free 的block与自身合并，并更新相关的链表指针。
  \end{enumerate}
\end{itemize}
\p 容易看到，\c{ManagedHeap}无论是\c{Allocate}还是\c{Free}都只需要$O(1)$的时间复杂度。并且在打开release优化之后，ManagedHeap的运行速度得到了更大幅度的提升。采用ManagedHeap之后，插入带索引的10万行记录时间减少到了10秒左右。

\s{个人总结}
\p 通过本项目，我了解并实现了数据库系统一种可能的具体架构，加深了对数据库系统底层架构的认识，也了解了在数据库程序运行过程中几个性能瓶颈所在。同时，本项目也极大地提升了我的工程能力与代码组织能力，能够着手编写较多文件的大型项目。最终项目能够正确运行，并支持海量数据的基本操作，非常有收获感。
\p 不足的是，在整个项目完成之后，我才想到了一种通过优化索引存储的方式来极大地加速比较过程的方法。其次，ManagedHeap的实现还存在很多缺点，比如：对于大量碎片化的内存，占用额外内存空间过多，时间复杂度常数过大，且对缓存不友好，后续的改进可以参考微软出品的mi-malloc。此外，由于时间原因，未能实现事务管理、真正的查询优化，还无法支持普遍意义上的SQL语句。
\end{document}